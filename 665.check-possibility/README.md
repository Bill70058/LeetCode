### 655.checkPossibility
----
#### 题目
给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。

----
#### 示例

##### 示例 1:

```
输入: [4,2,3]
输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
```

##### 示例 2:

```
输入: [4,2,1]
输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
说明:  n 的范围为 [1, 10,000]。
```

----
#### 解题思路
这题的解题要比较前后两个元素，而不是只比较后一个元素，因为更改当前元素的话有可能与前一个元素形成递减序列
当只有任意的两个数的时候，只要更改一次即可；
当三个或以上的数的时候，假设在遍历中，前一个数为x，当前的数为y，后一个数为z
> 【表1】
```
x    y   z
1    3   2
2    3   1
3    3   1
2    3   2
```
假设当前在遍历中，判断条件为当前元素大于后一个元素 -- 
- 当前元素是数组元素下标为 0 的元素的话，后一个元素赋值给前一个元素，这样就能确保不会和再往后一个的元素形成递减序列
例如``[4,2,3]``如果将当前元素``4``赋值给后一个元素，他就会与再往后一个的元素形成递减序列


- 如果当前元素下标非 0 ，也就是说有前一个元素了，那么此时就要比较前一个元素与后一个元素，因为前面的元素是被遍历更改对比过来的(下标为 0）如果大于后一个元素的话会被赋值等于后一个元素，所以最大也只是与当前元素相同(例如[4,3,2] -> [2,2,3])。
假设当前元素下标为 1，如果前一个元素大于后一个元素那么就会出现表一的情况，有三种情况

```
1，当x<z,让y=z
2，当x>z,让z=y
3, 当x=z,让y=z
```
**综合以上可以得到：当x存在且x>z，就让z=y，否则让y=z**
因此 ``if(i-1 > 0 && nums[i-1] > nums[i+1])``

**注意**：循环条件为长度减一，因为要判断后一个与前一个的对比